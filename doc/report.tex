\documentclass[12pt]{article}
\usepackage{amsmath,amssymb,amsthm, minted, hyperref, enumerate, graphics, graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{Loom Proof of Concept}
\author{Mahesh Khanwalkar}
\date{}

\begin{document}
    \maketitle
    \section{Introduction}

    Project Loom is an effort to add scoped, one-shot delimited continuations to Java, along with the
    necessary runtime support within the JVM. Third-party implementations of delimited continuations, like
    Kilim required an explicit, after-compilation weaving process; however, this is not necessary within
    Loom.

    \subsection{Loom API}

    The way of creating continuations is through the aptly-named Continuation class, which encapsulates a
    Runnable target. The continuation can be started for the first time using a call to the run method:

    \begin{lstlisting}
    // Runnable body is wrapped within the continuation
    Continuation cont = new Continuation(body); 
    cont.run();
    \end{lstlisting}

    This call performs all the necessary setup required, which includes the support for handling yielding.
    Within the Runnable body, the continuation can be yielded using a static call to Continuation.yield,
    which will cause the call to run to return. However, the same condition is true when the continuation
    simplify finishes. Therefore, it is up to the caller to check whether the continuation actually finished.
    It is up to the user of the continuation to resume it, which can be done using the same run call.

    \begin{lstlisting}
    if(cont.isDone()) {
        // The continuation has finished
    } else {
        // The continuation has yielded (suspended)
        // Calling run will resume right after the point of suspension.
        cont.run();
    }
    \end{lstlisting}

    \subsection{Limitations}
    The API is still currently under active development, so there are still some limitations. The only
    exposed state of a continuation is whether it is done or not. There is no way to tell from another thread
    that the continuation has yielded.

    The documentation mentions a Fiber class, which would manage the scheduling of continuations and states
    that continuations are not necessarily meant to be used directly, since they are quite low-level.
    However, there seems to be a gap between the documentation and the current state of the code base. 

    There was a Fiber class in an earlier build, but it was marked package private, so it is quite likely
    that it was not supposed to be used directly. In addition, in newer builds, it looks like the class has
    been removed completely. The only public, relatively-stable interface is the Continuation class. 

    Since Project Loom is under active development, it is natural that there are still many bugs. JVM crashes
    do occur occasionally, so some of the runtime support does seem to have some issues that need to be
    resolved. Debugging also occasionally causes the JVM to crash as well which is not ideal. However, for
    the most part, the current state of Loom is stable enough and feature-ready enough to be used to
    implement higher level parallelism constructs.

    \section{Purpose}

    The main objective of this proof-of-concept is to demonstrate how to implement certain high level
    parallelism constructs with the features provided in Loom. This implementation was done from the ground
    up to allow for design flexibility and faster completion than trying to migrate parts of the existing
    Habanero Java library. While the end goal is to do this migration, this project acts as a logic stepping
    stone, hopefully guiding the effort through the initial stages.

    The two high level parallelism constructs that were chosen were \textbf{async} and \textbf{finish}, which
    are arguably the most fundamental. Many other constructs, like parallel for, can be built on top of these
    so it makes sense to start here. Both the runtime design and the library interface were designed to be
    similar to the original HJ library implementation. Functional interfaces and lambdas, just like with the
    original HJLib, were employed to mimic the construct style used by X10 and the Habanero Java language.

    This objective was achieved -- both \textbf{async} and \textbf{finish} were fully implemented and tested
    with simple examples. The details of the runtime implementation, continuation setup, and other important
    information is layed out within the next couple sections. There are still some small issues with the
    current source; however, those are runtime related: the constructs are working as expected. 

    Lastly, the code itself has been documented extensively. Since the end goal of this proof-of-concept is
    to serve as a starting point for a larger migration effort, adequate documentation would be very helpful.
    Both the runtime and construct aspects have lengthy javadocs that explain everything in detail. Debugging
    the components is also relatively straightforward, although the issues with continuation debugging do
    occasionally make things complicated. However, this will ideally be resolved as Project Loom matures with
    time.

    \section{Design Process}

    The project was split into two logically-separate units: constructs and runtime support. The constructs
    define the \textbf{async} and \textbf{finish} methods while the runtime support implements all the task
    management and scheduling internals.

    \subsection{Constructs}

    The constructs were defined within a Construct class which contains static methods. In addition to the
    \textbf{async} and \textbf{finish} methods, there is also a \textbf{launchApp} method. This is used to
    enter a scope where the runtime is active and ready to accept tasks. Once control returns from this
    method, the runtime automatically waits on any remaining tasks and then shuts down, freeing up any
    resources that were allocated.

    Since the runtime is only active within the \textbf{launchApp} scope, it follows that the high-level
    parallelism constructs must be called within this scope. The following code snippet demonstrates how this
    would look like:

    \begin{lstlisting}
        launchApp(() -> myJob());
        ...
        public void myJob()
        {
            finish(() -> {
                System.out.println("Task #1");
                async(() -> {
                    System.out.println("Task #2");
                });
            });
        }
    \end{lstlisting}

    The myJob method encapsulates a single job which is made up of two tasks. The task creation and
    management is all handled by the runtime, since this method is passed to the launchApp method. It is also
    possible to directly provide the body of myJob to launchApp, as shown below:

    \begin{lstlisting}
        launchApp(() -> {
            finish(() -> {
                System.out.println("Task #1");
                async(() -> {
                    System.out.println("Task #2");
                });
            });
        });
    \end{lstlisting}

    For very small code snippets, this makes sense. However, for the most part, it is best to encapsulate the
    job into its own method. There are no restrictions when it comes to the method composition of the job:
    control can freely enter and return from as many methods as so desired (constrained by stack limits)

    \subsection{Runtime}

    The runtime is where all of the actual task management work happens. The constructs merely act as a
    convenient wrapper which calls into the runtime for all of its needs. 

    \subsubsection{Construct Implementation}

    \begin{lstlisting}
    /**
     * Launch a new "application" to run on the runtime framework
     * @param body - root body of the task
     * @throws InterruptedException - if the wait-to-finish is interrupted
     */
    public static void launchApp(Runnable body) throws InterruptedException
    {
        // Only one runtime can be launched at a time
        if(runtime != null)
            return;

        runtime = new LoomRuntime();
        runtime.submitRoot(body);
        runtime.waitOnRoot();
        runtime.shutdown();
    }
    \end{lstlisting}

    As described earlier, the launchApp method will initialise the runtime and submit the provided body as
    the root task. Therefore, all jobs start out with a single task, but have the option of creating new ones
    via the \textbf{async} construct. Once the root task has been submitted, the method waits until the
    runtime indicates that this task and all its children have completed.

    It is important to note that the root task has an implicit finish scope. That is, the root task cannot
    be considered complete until all of its child tasks have also completed. Therefore, regardless of whether
    there is a call to finish with the runnable body, then runtime ensures that this implicit finish behaviour
    is preserved.

    Another important note is that the Construct API only directly deals with Runnable. The continuations are
    only seen within the runtime itself. This is due to the fact that there is no weaving process -- support
    for continuations is at a JVM level. Therefore, there is no need for special interfaces or annotations
    to indicate which methods need to be weaved after compilation. 

    The implementations for \textbf{async} and \textbf{finish} are even simpler, since they directly call the
    runtime without any additional work:

    \begin{lstlisting}
    /**
     * Spawn an async task to execute the body
     *
     * This call should only be executed within the launchApp { ... }
     * scope, since the Loom Runtime needs to be initialised.
     *
     * The 'body' specified will be wrapped within a new task and will
     * be scheduled to execute independently.
     *
     * @param body - body of the async task
     */
    public static void async(Runnable body)
    {
        runtime.setupAsync(body);
    }

    /**
     * Define a finish scope encapsulating the body
     *
     * This call should only be called within the launchApp {...} scope, since it
     * requires the Loom Runtime to be initialised.
     *
     * All instructions execute sequentially within the body, except for 
     * async {...} calls, which will spawn independent tasks to execute alongside
     * the original thread. 
     *
     * However, once the finish { ... } body is done, it will wait on any 
     * outstanding async calls which still need to complete.
     *
     * @param body - encapsulated body within the finish
     */
    public static void finish(Runnable body)
    {
       runtime.setupFinish(body);
    }
    \end{lstlisting}

    Once again, there is no mention of Continuations or even tasks. This has all been encapsulated within the
    runtime itself. The included javadocs explain the behaviour of the \textbf{async} and \textbf{finish}
    constructs. However, the actual details of what is going on is within the runtime itself. That is where
    the finish scope handling and task spawning takes place. The details of this are explored within the next
    subsection.
\end{document}
